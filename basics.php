<?php
/*
	$this - ссылка на вызываемый объект 
	(исключение: если метод был вызван статически из контекста другого объекта).
	$this доступна если метод был вызван в контексте объекта. 		
*/
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this определена (';echo get_class($this);echo ")\n";
        } else {
            echo "\$this не определена.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.
    }
}

$a = new A();
$a->foo();
A::foo(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.
$b = new B();
$b->bar();
B::bar(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.

/*
Результат выполнения данного примера:

$this определена (A)
$this не определена.
$this определена (B)
$this не определена.
====================================================================================================
*/

/*
new

Новый объект всегда будет создан, за исключением случаев, когда он содержит конструктор, 
в котором определен вызов исключения в случае ошибки.

В контексте класса можно создать новый объект через new self и new parent.
Копию объекта можно создать через функцию клонирования.

Пример Присваивание объекта
*/

$instance = new SimpleClass();

$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned будет иметь это значение';

$instance = null; // $instance и $reference становятся null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
/*
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned будет иметь это значение"
}
*/

/*
	extends.
	
	final метод не переопределяется
	Доступ к переопределенным методам или статическим методам путем обращения к ним будет через parent
	При переопределении методов - количество и типы аргументов должны оставаться такими же как и были
*/

/*
	::class
	Начиная с версии PHP 5.5 можно использовать ключевое слово class для разрешения имени класса. 
	С помощью конструкции ClassName::class можно получить строку с абсолютным именем класса ClassName. 
	Обычно это довольно полезно при работе с классами, использующими пространства имен.
*/

namespace NS {
    class ClassName {
    }

    echo ClassName::class;
}
/*
Результат выполнения данного примера:

NS\ClassName
*/

/*
	Свойства
	Инициализация дожна применяться для константных значений.
	 public $var6 = myConstant;
	 public $var7 = array(true, false);
	Переменные же должны быть вычислены во время компиляции.
	.........................................
			Так делать не надо
		public $var3 = 1+2;
		public $var4 = self::myStaticMethod();
	..........................................
	Доступ к статическим свойствам может быть получен с помощью :: (двойного двоеточия): self::$property.
*/

/*
	Константы классов
	Интерфейсы также могут содержать константы (constants).
*/
class MyClass
{
    const CONSTANT = 'значение константы';

    function showConstant() {
        echo  self::CONSTANT . "\n";
    }
}

/*
	Автоматическая загрузка классов
	Можно определить функцию __autoload()- будет автоматически вызвана 
	при использовании ранее неопределенного класса или интерфейса. 
	Вызов этой функции - последний шанс для интерпретатора загрузить класс прежде, чем он закончит 
	выполнение скрипта с ошибкой.

	Подсказка
	spl_autoload_register() -  предоставляет более гибкую альтернативу для автоматической загрузки классов. 
	
	Замечание:
		До версии 5.3.0, исключения, вызванные в функции __autoload, 
		не могли быть перехвачены в блоке catch и завершались с неисправимой ошибкой. 
		Начиная с версии 5.3.0 эти исключения можно перехватывать в ближайшем блоке catch. 
		Если бросить определенное пользователем исключение, 
		то класс этого исключения должен быть доступен. 
		Функция __autoload также может использоваться рекурсивно для автоматической загрузки 
		пользовательских классов исключений.
	Замечание:
			Если имя класса используется, например, для вызова через call_user_func(), 
			то оно может содержать некоторые опасные символы, такие как ../. 
			Поэтому, рекомендуется не использовать данные от пользователей в таких функциях или же, 
			как минимум, проверять значения в __autoload().
*/
function __autoload($class_name) {
    include $class_name . '.php';
}

$obj  = new MyClass1();
$obj2 = new MyClass2(); 

/*
	Автоматическая загрузка с перехватом исключения в версиях 5.3.0+
	В данном примере вызывается исключение и отлавливается блоком try/catch.
*/
<?php
function __autoload($name) {
    echo "Want to load $name.\n";
    throw new Exception("Unable to load $name.");
}

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}

/*
	Конструкторы и деструкторы
	Замечание: Конструкторы в классах-родителях не вызываются автоматически
	function __construct() {}
	void __destruct ( void )
	Замечание: Деструкторы в классах-родителях не вызываются автоматически
	Деструктор будет вызван даже в том случае, если скрипт был остановлен с помощью функции exit(). 
	Вызов exit() в деструкторе предотвратит запуск всех последующих функций завершения.
	Замечание:
	Попытка бросить исключение в деструкторе (вызванного во время завершения скрипта) 
	влечет за собой фатальную ошибку.
*/

/*
	Область видимости
	
	Видимость из других объектов
	Объекты одного типа имеют доступ к элементам с модификаторами private и protected друг друга, 
	даже если не являются одним и тем же экземпляром.
	
	Это объясняется тем, что реализация видимости элементов известна внутри этих объектов.
	
	Это все значит, что передав объект класс в метод этого же класса, мы можем изменять private свойства напрямую.
	(см. пример ниже там понятнее).
	
*/

class Test
{
    private $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    private function bar()
    {
       var_dump ('Access to private methode:'.$this->foo);
    }
	
	public function qqq () {
		return $this->foo;
	}
	
    public function baz(Test $other)
    {
        // Мы можем изменить закрытое свойство:
        $other->foo = 'hello';
        // Мы также можем вызвать закрытый метод:
        $other->bar();
    }
}

$test = new Test('test');
$other = new Test('other');
$test->baz($other);

var_dump($test->qqq());
var_dump($other->qqq());

/*
	Access to private methode:hello
	test
	hello
*/

/*
	Оператор разрешения области видимости (::) 
	Позволяет обращаться к статическим свойствам, константам и перегруженным свойствам или методам класса.
	
	Для обращения к свойствам и методам внутри самого класса используются ключевые слова self, parent и static.
*/

/*
	Ключевое слово "static"
	Так как статические методы вызываются без создания экземпляра класса, 
	то псевдо-переменная $this не доступна внутри метода, объявленного статическим.

	Доступ к статическим свойствам класса не может быть получен через оператор ->.

*/

/*
	Абстрактные классы
	При наследовании от абстрактного класса область видимости этих методов должна совпадать (или быть менее строгой)
	Сигнатуры методов должны совпадать, т.е. контроль типов (type hint) и количество обязательных аргументов 
	должно быть одинаковым.
*/

/*
	Интерфейсы объектов
	Все методы, определенные в интерфейсы должны быть публичными
	
	Замечание:
	До версии PHP 5.3.9 класс не мог реализовывать два интерфейса, которые описывали метод с одинаковым именем,
	так как это приводило к неоднозначности. Новые версии PHP позволяют это делать, 
	если методы имеют одинаковую сигнатуру.
	
	Интерфейсы могут содержать константы. 
*/

/*
	Перегрузка
	
	Перегрузка в PHP означает возможность динамически "создавать" свойства и методы. 
	Эти динамические сущности обрабатываются с помощью "волшебных" методов, которые можно создать 
	в классе для различных видов действий.

	Методы перегрузки вызываются, когда свойства или методы не видны в текущей области видимости

	Все методы перегрузки должны быть объявлены как public.
	
	Замечание:
	Ни один аргумент не может быть передан по ссылке в эти "волшебные" методы.
	
	Метод __set($nameб $value) будет выполнен при записи данных в недоступные свойства.
	Метод __get($name) будет выполнен при чтении данных из недоступных свойств.
	Метод __isset($name) будет выполнен при использовании isset() или empty() на недоступных свойствах.
	Метод __unset($name) будет выполнен при вызове unset() на недоступном свойстве.
	$name - имя вызываемого свойства
	
	Перегрузка свойств работает только в контексте объекта. Не могут быть статическими
	
	Замечание:
	Возвращаемое значение метода __set() будет проигнорировано из-за способа обработки 
	в PHP оператора присваивания. Аналогично, __get() никогда не вызовется при цепных присваиваниях, 
	например, таких:
	$a = $obj->b = 8; 
*/

class PropertyTest 
{
    /**  Место хранения перегружаемых данных.  */
    private $data = array();

    /**  Перегрузка не применяется к объявленным свойствам.  */
    public $declared = 1;

    /**  Здесь перегрузка будет использована только при доступе вне класса.  */
    private $hidden = 2;

    public function __set($name, $value) 
    {
        echo "Установка '$name' в '$value'\n";
        $this->data[$name] = $value;
    }

    public function __get($name) 
    {
        echo "Получение '$name'\n";
        if (array_key_exists($name, $this->data)) {
            return $this->data[$name];
        }

        $trace = debug_backtrace();
        trigger_error(
            'Неопределенное свойство в __get(): ' . $name .
            ' в файле ' . $trace[0]['file'] .
            ' на строке ' . $trace[0]['line'],
            E_USER_NOTICE);
        return null;
    }

    /**  Начиная с версии PHP 5.1.0  */
    public function __isset($name) 
    {
        echo "Установлено ли '$name'?\n";
        return isset($this->data[$name]);
    }

    /**  Начиная с версии PHP 5.1.0  */
    public function __unset($name) 
    {
        echo "Уничтожение '$name'\n";
        unset($this->data[$name]);
    }

    /**  Не "волшебный" метод, просто для примера. */
    public function getHidden() 
    {
        return $this->hidden;
    }
}


echo "<pre>\n";

$obj = new PropertyTest;

$obj->a = 1;
echo $obj->a . "\n\n";

var_dump(isset($obj->a));
unset($obj->a);
var_dump(isset($obj->a));
echo "\n";

echo $obj->declared . "\n\n";

echo "Давайте поэкспериментируем с private свойством 'hidden':\n";
echo "Private свойства видны внутри класса, поэтому __get() не используется...\n";
echo $obj->getHidden() . "\n";
echo "Private свойства не видны вне класса, поэтому __get() используется...\n";
echo $obj->hidden . "\n";

/*
	Результат выполнения данного примера:

	Установка 'a' в '1'
	Получение 'a'
	1

	Установлено ли 'a'?
	bool(true)
	Уничтожение 'a'
	Установлено ли 'a'?
	bool(false)

	1

	Давайте поэкспериментируем с private свойством 'hidden':
	Private свойства видны внутри класса, поэтому __get() не используется...
	2
	Private свойства не видны вне класса, поэтому __get() используется...
	Получение 'hidden'


	Notice:  Неопределенное свойство в __get(): hidden в файле <file> на строке 70 в <file> на строке 29
*/

/*
	Перегрузка методов

	public mixed __call ( string $name , array $arguments )
	public static mixed __callStatic ( string $name , array $arguments )
	В контексте объекта при вызове недоступных методов вызывается метод __call().

	В статическом контексте при вызове недоступных методов вызывается метод __callStatic().

	Аргумент $name представляет собой имя вызываемого метода. 
	Аргумент $arguments представляет собой числовой массив, содержащий параметры, 
	переданные в вызываемый метод $name.
*/

/*
	Ключевое слово "final"
	PHP 5 представляет ключевое слово final, разместив которое перед объявлениями методов класса, 
	можно предотвратить их переопределение в дочерних классах. Если же сам класс определяется 
	с этим ключевым словом, то он не сможет быть унаследован.
	
	Замечание: Свойства не могут быть объявлены окончательными, только классы и методы.

*/

/*
	Клонирование объектов
	
	Копия объекта создается с использованием ключевого слова clone (который вызывает метод __clone() объекта, если это возможно). 
	Вызов метода __clone() не может быть осуществлён непосредственно.
	
	При клонировании объекта, PHP 5 выполняет неполную копию всех свойств объекта. 
	Любые свойства, являющиеся ссылками на другие переменные, останутся ссылками.
	
	По завершении клонирования, если у класса был определен метод __clone(), то этот метод __clone() 
	вызывается у свежесозданной копии объекта, для возможного изменения всех необходимых свойств.
*/

/*
	Сравнение объектов
	
	При использовании оператора сравнения (==), свойства объектов просто сравниваются друг с другом, 
	а именно: два объекта равны, если они содержат одинаковые свойства и одинаковые значения, 
	и являются экземплярами одного и того же класса.

	При использовании оператора идентичности (===), переменные объектов считаются идентичными 
	тогда и только тогда, когда они ссылаются на один и тот же экземпляр одного и того же класса.
*/

/*
	Контроль типа
	
	PHP 5 предоставляет возможность использовать контроль типов. На данный момент функции имеют возможность 
	заставлять параметры быть либо объектами (путем указания имени класса в прототипе функции), либо интерфейсами, либо массивами (начиная с PHP 5.1), или колбеком с типом callable (начиная с PHP 5.4). Однако, если NULL использовался как значение параметра по умолчанию, то это будет также допустимо в качестве аргумента для последующего вызова.

	Если класс или интерфейс указан для контроля типа, то все его потомки или реализации также допустимы.

	Контроль типа не может быть использован со скалярными типами, такими как int или string.
	Ресурсы и Трейты также недопустимы.
*/

/*
	Позднее статическое связывание ( > PHP 5.3.0).
	Используется для того чтобы получить ссылку на вызываемый класс в контексте статического наследования.
*/

/*
	Пример #1 Использование self::
*/
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
	
	public static function test2() {
        static::who(); // Здесь действует позднее статическое связывание
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
B::test2();
/*
Результат выполнения данного примера:
A
B
*/

?>