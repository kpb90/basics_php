<?php
/*
	$this - ссылка на вызываемый объект 
	(исключение: если метод был вызван статически из контекста другого объекта).
	$this доступна если метод был вызван в контексте объекта. 		
*/
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this определена (';echo get_class($this);echo ")\n";
        } else {
            echo "\$this не определена.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.
    }
}

$a = new A();
$a->foo();
A::foo(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.
$b = new B();
$b->bar();
B::bar(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.

/*
Результат выполнения данного примера:

$this определена (A)
$this не определена.
$this определена (B)
$this не определена.
====================================================================================================
*/

/*
new

Новый объект всегда будет создан, за исключением случаев, когда он содержит конструктор, 
в котором определен вызов исключения в случае ошибки.

В контексте класса можно создать новый объект через new self и new parent.
Копию объекта можно создать через функцию клонирования.

Пример Присваивание объекта
*/

$instance = new SimpleClass();

$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned будет иметь это значение';

$instance = null; // $instance и $reference становятся null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
/*
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned будет иметь это значение"
}
*/

/*
	extends.
	
	final метод не переопределяется
	Доступ к переопределенным методам или статическим методам путем обращения к ним будет через parent
	При переопределении методов - количество и типы аргументов должны оставаться такими же как и были
*/

/*
	::class
	Начиная с версии PHP 5.5 можно использовать ключевое слово class для разрешения имени класса. 
	С помощью конструкции ClassName::class можно получить строку с абсолютным именем класса ClassName. 
	Обычно это довольно полезно при работе с классами, использующими пространства имен.
*/

namespace NS {
    class ClassName {
    }

    echo ClassName::class;
}
/*
Результат выполнения данного примера:

NS\ClassName
*/

/*
	Свойства
	Инициализация дожна применяться для константных значений.
	 public $var6 = myConstant;
	 public $var7 = array(true, false);
	Переменные же должны быть вычислены во время компиляции.
	.........................................
			Так делать не надо
		public $var3 = 1+2;
		public $var4 = self::myStaticMethod();
	..........................................
	Доступ к статическим свойствам может быть получен с помощью :: (двойного двоеточия): self::$property.
*/

/*
	Константы классов
	Интерфейсы также могут содержать константы (constants).
*/
class MyClass
{
    const CONSTANT = 'значение константы';

    function showConstant() {
        echo  self::CONSTANT . "\n";
    }
}

/*
	Автоматическая загрузка классов
	Можно определить функцию __autoload()- будет автоматически вызвана 
	при использовании ранее неопределенного класса или интерфейса. 
	Вызов этой функции - последний шанс для интерпретатора загрузить класс прежде, чем он закончит 
	выполнение скрипта с ошибкой.

	Подсказка
	spl_autoload_register() -  предоставляет более гибкую альтернативу для автоматической загрузки классов. 
	
	Замечание:
		До версии 5.3.0, исключения, вызванные в функции __autoload, 
		не могли быть перехвачены в блоке catch и завершались с неисправимой ошибкой. 
		Начиная с версии 5.3.0 эти исключения можно перехватывать в ближайшем блоке catch. 
		Если бросить определенное пользователем исключение, 
		то класс этого исключения должен быть доступен. 
		Функция __autoload также может использоваться рекурсивно для автоматической загрузки 
		пользовательских классов исключений.
	Замечание:
			Если имя класса используется, например, для вызова через call_user_func(), 
			то оно может содержать некоторые опасные символы, такие как ../. 
			Поэтому, рекомендуется не использовать данные от пользователей в таких функциях или же, 
			как минимум, проверять значения в __autoload().
*/
function __autoload($class_name) {
    include $class_name . '.php';
}

$obj  = new MyClass1();
$obj2 = new MyClass2(); 

/*
	Автоматическая загрузка с перехватом исключения в версиях 5.3.0+
	В данном примере вызывается исключение и отлавливается блоком try/catch.
*/
<?php
function __autoload($name) {
    echo "Want to load $name.\n";
    throw new Exception("Unable to load $name.");
}

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}

/*
	Конструкторы и деструкторы
	Замечание: Конструкторы в классах-родителях не вызываются автоматически
	function __construct() {}
	void __destruct ( void )
	Замечание: Деструкторы в классах-родителях не вызываются автоматически
	Деструктор будет вызван даже в том случае, если скрипт был остановлен с помощью функции exit(). 
	Вызов exit() в деструкторе предотвратит запуск всех последующих функций завершения.
	Замечание:
	Попытка бросить исключение в деструкторе (вызванного во время завершения скрипта) 
	влечет за собой фатальную ошибку.
*/

/*
	Область видимости
	
	Видимость из других объектов
	Объекты одного типа имеют доступ к элементам с модификаторами private и protected друг друга, 
	даже если не являются одним и тем же экземпляром.
	
	Это объясняется тем, что реализация видимости элементов известна внутри этих объектов.
	
	Это все значит, что передав объект класс в метод этого же класса, мы можем изменять private свойства напрямую.
	(см. пример ниже там понятнее).
	
*/

class Test
{
    private $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    private function bar()
    {
       var_dump ('Access to private methode:'.$this->foo);
    }
	
	public function qqq () {
		return $this->foo;
	}
	
    public function baz(Test $other)
    {
        // Мы можем изменить закрытое свойство:
        $other->foo = 'hello';
        // Мы также можем вызвать закрытый метод:
        $other->bar();
    }
}

$test = new Test('test');
$other = new Test('other');
$test->baz($other);

var_dump($test->qqq());
var_dump($other->qqq());

/*
	Access to private methode:hello
	test
	hello
*/

/*
	Оператор разрешения области видимости (::) 
	Позволяет обращаться к статическим свойствам, константам и перегруженным свойствам или методам класса.
	
	Для обращения к свойствам и методам внутри самого класса используются ключевые слова self, parent и static.
*/

/*
	Ключевое слово "static"
	Так как статические методы вызываются без создания экземпляра класса, 
	то псевдо-переменная $this не доступна внутри метода, объявленного статическим.

	Доступ к статическим свойствам класса не может быть получен через оператор ->.

*/

/*
	Абстрактные классы
	При наследовании от абстрактного класса область видимости этих методов должна совпадать (или быть менее строгой)
	Сигнатуры методов должны совпадать, т.е. контроль типов (type hint) и количество обязательных аргументов 
	должно быть одинаковым.
*/

/*
	Интерфейсы объектов
	Все методы, определенные в интерфейсы должны быть публичными
	
	Замечание:
	До версии PHP 5.3.9 класс не мог реализовывать два интерфейса, которые описывали метод с одинаковым именем,
	так как это приводило к неоднозначности. Новые версии PHP позволяют это делать, 
	если методы имеют одинаковую сигнатуру.
	
	Интерфейсы могут содержать константы. 
*/

/*
	Перегрузка
	
	Перегрузка в PHP означает возможность динамически "создавать" свойства и методы. 
	Эти динамические сущности обрабатываются с помощью "волшебных" методов, которые можно создать 
	в классе для различных видов действий.

	Методы перегрузки вызываются, когда свойства или методы не видны в текущей области видимости

	Все методы перегрузки должны быть объявлены как public.
	
	Замечание:
	Ни один аргумент не может быть передан по ссылке в эти "волшебные" методы.
	
	Метод __set($nameб $value) будет выполнен при записи данных в недоступные свойства.
	Метод __get($name) будет выполнен при чтении данных из недоступных свойств.
	Метод __isset($name) будет выполнен при использовании isset() или empty() на недоступных свойствах.
	Метод __unset($name) будет выполнен при вызове unset() на недоступном свойстве.
	$name - имя вызываемого свойства
	
	Перегрузка свойств работает только в контексте объекта. Не могут быть статическими
	
	Замечание:
	Возвращаемое значение метода __set() будет проигнорировано из-за способа обработки 
	в PHP оператора присваивания. Аналогично, __get() никогда не вызовется при цепных присваиваниях, 
	например, таких:
	$a = $obj->b = 8; 
*/

class PropertyTest 
{
    /**  Место хранения перегружаемых данных.  */
    private $data = array();

    /**  Перегрузка не применяется к объявленным свойствам.  */
    public $declared = 1;

    /**  Здесь перегрузка будет использована только при доступе вне класса.  */
    private $hidden = 2;

    public function __set($name, $value) 
    {
        echo "Установка '$name' в '$value'\n";
        $this->data[$name] = $value;
    }

    public function __get($name) 
    {
        echo "Получение '$name'\n";
        if (array_key_exists($name, $this->data)) {
            return $this->data[$name];
        }

        $trace = debug_backtrace();
        trigger_error(
            'Неопределенное свойство в __get(): ' . $name .
            ' в файле ' . $trace[0]['file'] .
            ' на строке ' . $trace[0]['line'],
            E_USER_NOTICE);
        return null;
    }

    /**  Начиная с версии PHP 5.1.0  */
    public function __isset($name) 
    {
        echo "Установлено ли '$name'?\n";
        return isset($this->data[$name]);
    }

    /**  Начиная с версии PHP 5.1.0  */
    public function __unset($name) 
    {
        echo "Уничтожение '$name'\n";
        unset($this->data[$name]);
    }

    /**  Не "волшебный" метод, просто для примера. */
    public function getHidden() 
    {
        return $this->hidden;
    }
}


echo "<pre>\n";

$obj = new PropertyTest;

$obj->a = 1;
echo $obj->a . "\n\n";

var_dump(isset($obj->a));
unset($obj->a);
var_dump(isset($obj->a));
echo "\n";

echo $obj->declared . "\n\n";

echo "Давайте поэкспериментируем с private свойством 'hidden':\n";
echo "Private свойства видны внутри класса, поэтому __get() не используется...\n";
echo $obj->getHidden() . "\n";
echo "Private свойства не видны вне класса, поэтому __get() используется...\n";
echo $obj->hidden . "\n";

/*
	Результат выполнения данного примера:

	Установка 'a' в '1'
	Получение 'a'
	1

	Установлено ли 'a'?
	bool(true)
	Уничтожение 'a'
	Установлено ли 'a'?
	bool(false)

	1

	Давайте поэкспериментируем с private свойством 'hidden':
	Private свойства видны внутри класса, поэтому __get() не используется...
	2
	Private свойства не видны вне класса, поэтому __get() используется...
	Получение 'hidden'


	Notice:  Неопределенное свойство в __get(): hidden в файле <file> на строке 70 в <file> на строке 29
*/

/*
	Перегрузка методов

	public mixed __call ( string $name , array $arguments )
	public static mixed __callStatic ( string $name , array $arguments )
	В контексте объекта при вызове недоступных методов вызывается метод __call().

	В статическом контексте при вызове недоступных методов вызывается метод __callStatic().

	Аргумент $name представляет собой имя вызываемого метода. 
	Аргумент $arguments представляет собой числовой массив, содержащий параметры, 
	переданные в вызываемый метод $name.
*/

/*
	Ключевое слово "final"
	PHP 5 представляет ключевое слово final, разместив которое перед объявлениями методов класса, 
	можно предотвратить их переопределение в дочерних классах. Если же сам класс определяется 
	с этим ключевым словом, то он не сможет быть унаследован.
	
	Замечание: Свойства не могут быть объявлены окончательными, только классы и методы.

*/

/*
	Клонирование объектов
	
	Копия объекта создается с использованием ключевого слова clone (который вызывает метод __clone() объекта, если это возможно). 
	Вызов метода __clone() не может быть осуществлён непосредственно.
	
	При клонировании объекта, PHP 5 выполняет неполную копию всех свойств объекта. 
	Любые свойства, являющиеся ссылками на другие переменные, останутся ссылками.
	
	По завершении клонирования, если у класса был определен метод __clone(), то этот метод __clone() 
	вызывается у свежесозданной копии объекта, для возможного изменения всех необходимых свойств.
*/

/*
	Сравнение объектов
	
	При использовании оператора сравнения (==), свойства объектов просто сравниваются друг с другом, 
	а именно: два объекта равны, если они содержат одинаковые свойства и одинаковые значения, 
	и являются экземплярами одного и того же класса.

	При использовании оператора идентичности (===), переменные объектов считаются идентичными 
	тогда и только тогда, когда они ссылаются на один и тот же экземпляр одного и того же класса.
*/

/*
	Контроль типа
	
	PHP 5 предоставляет возможность использовать контроль типов. На данный момент функции имеют возможность 
	заставлять параметры быть либо объектами (путем указания имени класса в прототипе функции), либо интерфейсами, либо массивами (начиная с PHP 5.1), или колбеком с типом callable (начиная с PHP 5.4). Однако, если NULL использовался как значение параметра по умолчанию, то это будет также допустимо в качестве аргумента для последующего вызова.

	Если класс или интерфейс указан для контроля типа, то все его потомки или реализации также допустимы.

	Контроль типа не может быть использован со скалярными типами, такими как int или string.
	Ресурсы и Трейты также недопустимы.
*/

/*
	Позднее статическое связывание ( > PHP 5.3.0).
	Используется для того чтобы получить ссылку на вызываемый класс в контексте статического наследования.
*/

/*
	Пример #1 Использование self::
*/
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
	
	public static function test2() {
        static::who(); // Здесь действует позднее статическое связывание
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test();
B::test2();
/*
Результат выполнения данного примера:
A
B
*/


/*
	Пространство имен
	
	Аналогии с файловой системой.
	Есть три способа обратиться к файлу в файловой системе:
	
	Пусть currentdirectory текущая директория
	
	1) foo.txt преобразуется в currentdirectory/foo.txt, 
	2) subdirectory/foo.txt в currentdirectory/subdirectory/foo.txt
	3) /main/foo.txt в /main/foo.txt - абсолютное имя пути.

	Тот же принцип применим и к элементам из пространств имен PHP. 
	Для примера, имя класса может быть указано тремя способами:
	1) $a = new foo(); // в new currentnamespace\foo (). 
	Если код находится в глобальном пространстве имен, то имена остаются такими же: foo. 
	
	Неполные имена для функций и констант будут определяться в глобальном пространстве имен, 
	если они не определены в текущем пространстве имен.
	
	2) $a = new subnamespace\foo(); // в new currentnamespace\subnamespace\foo()

	3) $a = new \currentnamespace\foo(); // Абсолютные всегда остаются такими же.
	
	C пространством имен очень удобно работать когда есть автозагрузчик файлов. 
	Код пространство имен нужно оформлять в соответствии c PSR0.
*/

/*
	Ключевое слово namespace и константа __NAMESPACE__
	__NAMESPACE__ - это строка, которая содержит имя текущего пространства имен
	
	Ключевое слово namespace -  может быть использовано для явного запроса элемента из текущего пространства имен 
	или из подпространства. Это эквивалент оператора self для классов в пространстве имен.
*/

namespace MyProject;

use blah\blah as mine; // см. "Использование пространств имен: импорт/создание псевдонима имени"

blah\mine(); // вызывает функцию MyProject\blah\mine()
namespace\blah\mine(); // вызывает функцию MyProject\blah\mine()

namespace\func(); // вызывает функцию MyProject\func()
namespace\sub\func(); // вызывает функцию MyProject\sub\func()
namespace\cname::method(); // вызывает статический метод "method" класса MyProject\cname
$a = new namespace\sub\cname(); // Создает экземпляр класса MyProject\sub\cname
$b = namespace\CONSTANT; // присваивает значение константы MyProject\CONSTANT переменной $b

/*
	Использование пространств имен: импорт/создание псевдонима имени
	
	Существует три вида создания псевдонима имени или импорта: 
	1) создание псевдонима для имени класса
	2) создание псевдонима для имени интерфейса 
	3) для имени пространства имен. 
	PHP 5.6+ также поддерживает импорт функций и имен констант.
	
	use - оператор для создания псевдонима
	Важно: 
	Импортируемые имена должны быть абсолютными.
	Они не обрабатываются относительно текущего пространства имен.
	Поэтому нет необходимости в начальном обратном слеше (\) и его присутствие там 
	не рекомендуется. 
	
	То есть: если есть "use My\Full\NSname;"
		То можно писать вот так.
		NSname\subns\func(); - это запись преобразуется в NSname\subns\func();
	Иначе
		Оно преобразовалось бы  в foo\NSname\subns\func();
	
	Замечание:
	Правила импорта задаются на каждый файл отдельно. 
	Это означает, что присоединяемые файлы НЕ будут наследовать правила импорта из родительского файла.

*/
namespace foo;
use My\Full\Classname as Another;

// use My\Full\NSname as NSname
// Для удобства можно писать просто use My\Full\NSname
// Доступ будет доступен как My\Full\NSname, так и просто NSname
use My\Full\NSname;

// импортирование глобального класса
use ArrayObject;

// импортирование функции (PHP 5.6+)
use function My\Full\functionName;

// псевдоним функции (PHP 5.6+)
use function My\Full\functionName as func;

// импортирование константы (PHP 5.6+)
use const My\Full\CONSTANT;

$obj = new namespace\Another; // создает экземпляр класса foo\Another
$obj = new Another; // создает объект класса My\Full\Classname
NSname\subns\func(); // вызывает функцию My\Full\NSname\subns\func
$a = new ArrayObject(array(1)); // создает объект класса ArrayObject
// без выражения "use ArrayObject" мы создадим объект класса foo\ArrayObject
func(); // вызывает функцию My\Full\functionName
echo CONSTANT; // выводит содержимое константы My\Full\CONSTANT

/*
	Правила разрешения имен
	
	Определения имени пространства имен
	
	Неполное имя
	Это идентификатор без разделителя пространств имен, например, Foo

	Полное имя
	Это идентификатор с разделителем пространств имен, например, Foo\Bar

	Абсолютное имя
	Это идентификатор с разделителем пространств имен, который начинается с разделителя пространств имен, 
	например, \Foo\Bar. Пространство имен \Foo также является абсолютным именем.
	
	
	Внутри пространства имен (скажем, A\B), вызовы к неполным именам функций преобразуются 
	во время исполнения. 
	Пример: Преобразование вызова функции foo():
	Производится поиск функции из текущего пространства имен: A\B\foo().
	PHP пытается найти и вызвать функцию глобального пространства foo().
	
	
	Примеры разрешения имен
*/

namespace A;
use B\D, C\E as F;

// вызовы функций

foo();      // сперва пытается вызвать "foo", определенную в пространстве имен "A",
            // затем вызывает глобальную функцию "foo"

\foo();     // вызывает функцию "foo", определенную в глобальном пространстве

my\foo();   // вызывает функцию "foo", определенную в пространстве "A\my"

F();        // сперва пытается вызвать "F", определенную в пространстве имен "A",
            // затем вызывает глобальную функцию "F"

// ссылки на классы

new B();    // создает объект класса "B", определенного в пространстве имен "A".
            // если не найден, то пытается сделать автозагрузку класса "A\B"

new D();    // используя правила импорта, создает объект класса "D", определенного в пространстве имен "B"
            // если не найден, то пытается сделать автозагрузку класса "B\D"

new F();    // используя правила импорта, создает объект класса "E", определенного в пространстве имен "C"
            // если не найден, то пытается сделать автозагрузку класса "C\E"

new \B();   // создает объект класса "B", определенного в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса "B"

new \D();   // создает объект класса "D", определенного в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса "D"

new \F();   // создает объект класса "F", определенного в глобальном пространстве,
            // если не найден, то пытается сделать автозагрузку класса "F"

// статические методы/функции пространства имен из другого пространства имен

B\foo();    // вызывает функцию "foo" из пространства имен "A\B"

B::foo();   // вызывает метод "foo" из класса "B", определенного в пространстве имен "A"
            // если класс "A\B" не найден, то пытается сделать автозагрузку класса "A\B"

D::foo();   // используя правила импорта, вызывает метод "foo" класса "D", определенного в пространстве имен "B"
            // если класс "B\D" не найден, то пытается сделать автозагрузку класса "B\D"

\B\foo();   // вызывает функцию "foo" из пространства имен "B"

\B::foo();  // вызывает метод "foo" класса "B" из глобального пространства
            // если класс "B" не найден, то пытается сделать автозагрузку класса "B"

// статические методы/функции пространства имен из текущего пространства имен

A\B::foo();   // вызывает метод "foo" класса "B" из пространства имен "A\A"
              // если класс "A\A\B" не найден, то пытается сделать автозагрузку класса "A\A\B"

\A\B::foo();  // вызывает метод "foo" класса "B" из пространства имен "A"
              // если класс "A\B" не найден, то пытается сделать автозагрузку класса "A\B"

?>