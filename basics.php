<?php
/*
	$this - ссылка на вызываемый объект 
	(исключение: если метод был вызван статически из контекста другого объекта).
	$this доступна если метод был вызван в контексте объекта. 		
*/
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this определена (';echo get_class($this);echo ")\n";
        } else {
            echo "\$this не определена.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.
    }
}

$a = new A();
$a->foo();
A::foo(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.
$b = new B();
$b->bar();
B::bar(); // Замечание: следующая строка вызовет предупреждение, если включен параметр E_STRICT.

/*
Результат выполнения данного примера:

$this определена (A)
$this не определена.
$this определена (B)
$this не определена.
====================================================================================================
*/

/*
new

Новый объект всегда будет создан, за исключением случаев, когда он содержит конструктор, 
в котором определен вызов исключения в случае ошибки.

В контексте класса можно создать новый объект через new self и new parent.
Копию объекта можно создать через функцию клонирования.

Пример Присваивание объекта
*/

$instance = new SimpleClass();

$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned будет иметь это значение';

$instance = null; // $instance и $reference становятся null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
/*
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned будет иметь это значение"
}
*/

/*
	extends.
	
	final метод не переопределяется
	Доступ к переопределенным методам или статическим методам путем обращения к ним будет через parent
	При переопределении методов - количество и типы аргументов должны оставаться такими же как и были
*/

/*
	::class
	Начиная с версии PHP 5.5 можно использовать ключевое слово class для разрешения имени класса. 
	С помощью конструкции ClassName::class можно получить строку с абсолютным именем класса ClassName. 
	Обычно это довольно полезно при работе с классами, использующими пространства имен.
*/

namespace NS {
    class ClassName {
    }

    echo ClassName::class;
}
/*
Результат выполнения данного примера:

NS\ClassName
*/

/*
	Свойства
	Инициализация дожна применяться для константных значений.
	 public $var6 = myConstant;
	 public $var7 = array(true, false);
	Переменные же должны быть вычислены во время компиляции.
	.........................................
			Так делать не надо
		public $var3 = 1+2;
		public $var4 = self::myStaticMethod();
	..........................................
	Доступ к статическим свойствам может быть получен с помощью :: (двойного двоеточия): self::$property.
*/

/*
	Константы классов
	Интерфейсы также могут содержать константы (constants).
*/
class MyClass
{
    const CONSTANT = 'значение константы';

    function showConstant() {
        echo  self::CONSTANT . "\n";
    }
}

/*
	Автоматическая загрузка классов
	Можно определить функцию __autoload()- будет автоматически вызвана 
	при использовании ранее неопределенного класса или интерфейса. 
	Вызов этой функции - последний шанс для интерпретатора загрузить класс прежде, чем он закончит 
	выполнение скрипта с ошибкой.

	Подсказка
	spl_autoload_register() -  предоставляет более гибкую альтернативу для автоматической загрузки классов. 
	
	Замечание:
		До версии 5.3.0, исключения, вызванные в функции __autoload, 
		не могли быть перехвачены в блоке catch и завершались с неисправимой ошибкой. 
		Начиная с версии 5.3.0 эти исключения можно перехватывать в ближайшем блоке catch. 
		Если бросить определенное пользователем исключение, 
		то класс этого исключения должен быть доступен. 
		Функция __autoload также может использоваться рекурсивно для автоматической загрузки 
		пользовательских классов исключений.
	Замечание:
			Если имя класса используется, например, для вызова через call_user_func(), 
			то оно может содержать некоторые опасные символы, такие как ../. 
			Поэтому, рекомендуется не использовать данные от пользователей в таких функциях или же, 
			как минимум, проверять значения в __autoload().
*/
function __autoload($class_name) {
    include $class_name . '.php';
}

$obj  = new MyClass1();
$obj2 = new MyClass2(); 

/*
	Автоматическая загрузка с перехватом исключения в версиях 5.3.0+
	В данном примере вызывается исключение и отлавливается блоком try/catch.
*/
<?php
function __autoload($name) {
    echo "Want to load $name.\n";
    throw new Exception("Unable to load $name.");
}

try {
    $obj = new NonLoadableClass();
} catch (Exception $e) {
    echo $e->getMessage(), "\n";
}

/*
	Конструкторы и деструкторы
	Замечание: Конструкторы в классах-родителях не вызываются автоматически
	function __construct() {}
	void __destruct ( void )
	Замечание: Деструкторы в классах-родителях не вызываются автоматически
	Деструктор будет вызван даже в том случае, если скрипт был остановлен с помощью функции exit(). 
	Вызов exit() в деструкторе предотвратит запуск всех последующих функций завершения.
	Замечание:
	Попытка бросить исключение в деструкторе (вызванного во время завершения скрипта) 
	влечет за собой фатальную ошибку.
*/

/*
	Область видимости
	
	Видимость из других объектов
	Объекты одного типа имеют доступ к элементам с модификаторами private и protected друг друга, 
	даже если не являются одним и тем же экземпляром.
	
	Это объясняется тем, что реализация видимости элементов известна внутри этих объектов.
	
	Это все значит, что передав объект класс в метод этого же класса, мы можем изменять private свойства напрямую.
	(см. пример ниже там понятнее).
	
*/

class Test
{
    private $foo;

    public function __construct($foo)
    {
        $this->foo = $foo;
    }

    private function bar()
    {
       var_dump ('Access to private methode:'.$this->foo);
    }
	
	public function qqq () {
		return $this->foo;
	}
	
    public function baz(Test $other)
    {
        // Мы можем изменить закрытое свойство:
        $other->foo = 'hello';
        // Мы также можем вызвать закрытый метод:
        $other->bar();
    }
}

$test = new Test('test');
$other = new Test('other');
$test->baz($other);

var_dump($test->qqq());
var_dump($other->qqq());

/*
	Access to private methode:hello
	test
	hello
*/

/*
	Оператор разрешения области видимости (::) 
	Позволяет обращаться к статическим свойствам, константам и перегруженным свойствам или методам класса.
	
	Для обращения к свойствам и методам внутри самого класса используются ключевые слова self, parent и static.
*/

/*
	Ключевое слово "static"
	Так как статические методы вызываются без создания экземпляра класса, 
	то псевдо-переменная $this не доступна внутри метода, объявленного статическим.

	Доступ к статическим свойствам класса не может быть получен через оператор ->.

*/

/*
	Абстрактные классы
*/
?>